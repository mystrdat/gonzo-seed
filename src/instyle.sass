/*
  inStyle (v1.6.0)
  github.com/salsita/inStyle
  2016 | MIT
  ============================== */

// Configuration
$__inTagAppend: '<' !default
$__inTagInsert: '^' !default
$__inTagReplace: '@' !default

// String helpers
@function __trimString($string)
  $index: str-index($string, ' ')
  @if $index == 1
    @return __trimString(str-slice($string, $index + 1, -1))
  @else if $index == str-length($string)
    @return __trimString(str-slice($string, 1, $index - 1))
  @return $string

@function __stringToList($string, $delimiter: ',', $separator: comma)
  $list: ()
  $sum: str-length($string)
  @for $i from 1 through $sum
    $str: str-index($string, $delimiter)
    @if str-length($string) >= 1 and $str == null
      $list: append($list, unquote(__trimString($string)), $separator)
      $string: ''
    @if type-of($str) == number
      $each: str-slice($string, 0, ($str - 1))
      $list: append($list, unquote(__trimString($each)), $separator)
      $string: str-slice($string, ($str + 1), $sum)
  @return $list

// List helpers
@function __insertInList($list, $index, $value)
  $result: null
  @if $index > length($list)
    @warn "List index is #{$index} but list is only #{length($list)} items long for __insertInList()."
  @else
    $result: ()
    @for $i from 1 through length($list)
      @if $i == $index
        $result: append($result, $value)
      $result: append($result, nth($list, $i))
  @return $result

@function __removeFromList($list, $value, $recursive: false)
  $result: ()
  @for $i from 1 through length($list)
    @if type-of(nth($list, $i)) == list and $recursive
      $result: append($result, remove(nth($list, $i), $value, $recursive))
    @else if nth($list, $i) != $value
      $result: append($result, nth($list, $i))
  @return $result

@function __replaceInList($list, $old-value, $new-value, $recursive: false)
  $result: ()
  @for $i from 1 through length($list)
    @if type-of(nth($list, $i)) == list and $recursive
      $result: append($result, replace(nth($list, $i), $old-value, $new-value, $recursive))
    @else
      @if nth($list, $i) == $old-value
        $result: append($result, $new-value)
      @else
        $result: append($result, nth($list, $i))
  @return $result

@function __reverseList($list, $recursive: false)
  $result: ()
  @for $i from length($list)*-1 through -1
    @if type-of(nth($list, abs($i))) == list and $recursive
      $result: append($result, __reverseList(nth($list, abs($i)), $recursive))
    @else
      $result: append($result, nth($list, abs($i)))
  @return $result

@function __listToString($list, $glue: '', $is-nested: false)
  $result: null
  @for $i from 1 through length($list)
    $e: nth($list, $i)
    @if type-of($e) == list
      $result: unquote("#{$result}#{to-string($e, $glue, true)}")
    @else
      $result: if($i != length($list) or $is-nested, unquote("#{$result}#{$e}#{$glue}"), unquote("#{$result}#{$e}"))
  @return $result

@function __removeDuplicatesFromList($list, $recursive: false, $separator: comma)
  $result: ()
  @each $item in $list
    @if not index($result, $item)
      @if length($item) > 1 and $recursive
        $result: append($result, __removeDuplicatesFromList($item, $recursive), $separator)
      @else
        $result: append($result, $item, $separator)
  @return $result

// Custom helpers
@function __tagIndex($string, $tag)
  $index: 0
  @if str-index($string, $tag) == 1
    $index: 1
    $sum: str-length($string)
    @for $i from 2 through $sum
      @if str-slice($string, $i, $i) == $tag
        $index: $index + 1
      @else
        @return $index
  @return $index

@function __getDepthMap($selector, $current)
  $depthMap: ()
  @each $parent in $current
    // Save maximum length of matched compound to compare relevancy
    $parentIndex: index($current, $parent)
    $depthMap: append($depthMap, 0, comma)
    @each $compound in $selector
      // Check only for specific compound
      @if max(__tagIndex($compound, $__inTagInsert), __tagIndex($compound, $__inTagAppend), __tagIndex($compound, $__inTagReplace)) == 0
        $simple: simple-selectors($compound)
        // Test all matches starting with full compound and reducing for each step
        @for $i from 1 through length($simple)
          @if $i > 1
            $simple: __removeFromList($simple, nth($simple, length($simple)))
          @if index($parent, __listToString($simple)) and length($simple) > nth($depthMap, $parentIndex)
            // Relevancy scoring
            $depthIndex: index(__reverseList($parent), __listToString($simple)) + (length($simple) / 1000)
            $depthMap: set-nth($depthMap, $parentIndex, $depthIndex)
  @return $depthMap

// TODO: NO MAP FOR SINGLE SELECTOR
// TODO: DEDUPE ONLY WHEN DUPE EXPECTED
// TODO: MENTION TESTS IN README
// TODO: ALLOW ANY FLEXIBILITY

// In mixin
=in($selectors)
  $final: ()
  $current: &
  $selectors: __stringToList($selectors)
  @each $selector in $selectors
    $selector: __stringToList($selector, ' ', space)
    // Get deepest match indexes in all parents
    $depthMap: __getDepthMap($selector, $current)
    @for $n from 1 through length($current)
      // Render only best matching parents
      @if nth($depthMap, $n) == max($depthMap...)
        $parent: nth($current, $n)
        $newParent: __reverseList($parent)
        $startIndex: 1 // Start indexing above current element
        $lastIndex: $startIndex // Track last modified index
        $lastInsert: $startIndex // Track last insertion point
        // Process the modifications LTR
        @each $compound in $selector
          $appendIndex: __tagIndex($compound, $__inTagAppend)
          $insertIndex: __tagIndex($compound, $__inTagInsert)
          $replaceIndex: __tagIndex($compound, $__inTagReplace)
          $changeIndex: max($appendIndex, $insertIndex, $replaceIndex) + $startIndex

          // OUT_OF_BOUNDS check
          @if $changeIndex > length($parent)
            @error 'OUT_OF_BOUNDS: \'#{$compound}\' modification outside of \'#{$parent} {}\' (#{$changeIndex} vs #{length($parent)}).'

          @if $insertIndex > 0
            // Insert
            $lastIndex: $lastIndex + $insertIndex
            $lastInsert: $startIndex + $insertIndex
            $validatedCompound: __listToString(simple-selectors(str-slice($compound, $insertIndex + 1)))
            $newParent: __insertInList($newParent, $startIndex + $insertIndex, $validatedCompound)

          @else if $replaceIndex > 0
            // Replace
            $lastIndex: $lastIndex + $replaceIndex
            $validatedCompound: __listToString(simple-selectors(str-slice($compound, $replaceIndex + 1)))
            $newParent: __replaceInList($newParent, nth($newParent, $startIndex + $replaceIndex), $validatedCompound)

          @else if $appendIndex > 0
            // Append with tag
            $lastIndex: $lastIndex + $appendIndex
            $validatedCompound: nth($newParent, $lastIndex) + __listToString(simple-selectors(str-slice($compound, $appendIndex + 1)))
            $newParent: __replaceInList($newParent, nth($newParent, $appendIndex + 1), $validatedCompound)

          @else
            // Append with selector
            $simple: simple-selectors($compound)
            $state: ()
            $matched: false
            // Loop compound variants
            @for $i from 1 through length($simple)
              @if $i > 1
                $state: join(nth($simple, length($simple)), $state)
                $simple: __removeFromList($simple, nth($simple, length($simple)))
              $trySimple: __listToString($simple)
              $tryState: if($i > 1, __listToString($state), '')
              // Match base to reversed parent list
              @for $n from ($lastIndex + 1) through length($newParent)
                @if $n <= length($newParent) and $trySimple == nth($newParent, $n) and not $matched
                  // Save current index and enhance matched parent selector
                  $matched: true
                  $lastIndex: $n
                  $newParent: set-nth($newParent, $lastIndex, unquote($trySimple + $tryState))
            @if not $matched
              @error 'OUT_OF_BOUNDS: \'#{$compound}\' compound not found in \'#{__reverseList($newParent)}\'.'

        // Create new selectors
        $final: append($final, __reverseList($newParent), comma)
  // Remove possible duplicates from multiselector replacement
  $final: __removeDuplicatesFromList($final)
  // Render final selectors
  @at-root #{$final}
    @content
